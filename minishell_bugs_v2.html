<!DOCTYPE html>
<html lang="pt">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Minishell — Bug Report v2</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,300;0,400;0,600;0,700;1,400&family=Syne:wght@400;700;800&display=swap');

  :root {
    --bg: #080a0d;
    --surface: #0f1215;
    --surface2: #161a1f;
    --border: #1c2028;
    --text: #b8c4d0;
    --muted: #3d4a5a;
    --accent: #3dd68c;
    --red: #ff6b6b;
    --orange: #ff9f43;
    --yellow: #ffd166;
    --blue: #74b9ff;
    --purple: #a29bfe;
    --cyan: #00cec9;
    --strike: #ff6b6b;
  }
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'JetBrains Mono', monospace;
    font-size: 12.5px;
    line-height: 1.7;
  }

  /* ─── HEADER ─── */
  header {
    padding: 36px 56px 28px;
    border-bottom: 1px solid var(--border);
    display: flex; align-items: flex-end; justify-content: space-between;
  }
  .logo { font-family: 'Syne', sans-serif; font-weight: 800; font-size: 26px; color: #fff; }
  .logo em { color: var(--accent); font-style: normal; }
  .subtitle { color: var(--muted); font-size: 11px; margin-top: 5px; }
  .meta { text-align: right; color: var(--muted); font-size: 11px; }
  .meta strong { color: var(--text); font-size: 13px; display: block; }

  /* ─── LAYOUT ─── */
  .container { max-width: 1080px; margin: 0 auto; padding: 40px 56px 64px; }

  /* ─── CORRECTION BANNER ─── */
  .correction-banner {
    background: rgba(255,107,107,0.06);
    border: 1px solid rgba(255,107,107,0.2);
    border-radius: 6px;
    padding: 16px 20px;
    margin-bottom: 36px;
    font-size: 12px;
    color: var(--text);
    display: flex;
    gap: 12px;
    align-items: flex-start;
  }
  .correction-banner .icon { color: var(--red); font-size: 16px; flex-shrink: 0; margin-top: 1px; }
  .correction-banner strong { color: var(--red); }

  /* ─── SUMMARY ─── */
  .summary {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    gap: 10px;
    margin-bottom: 40px;
  }
  .stat {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 5px;
    padding: 16px 18px;
    position: relative; overflow: hidden;
  }
  .stat::after {
    content: ''; position: absolute; left: 0; top: 0; bottom: 0; width: 3px;
  }
  .stat.real::after { background: var(--red); }
  .stat.new::after { background: var(--orange); }
  .stat.minor::after { background: var(--yellow); }
  .stat.fp::after { background: var(--muted); }
  .stat.test::after { background: var(--blue); }
  .stat-num { font-family: 'Syne', sans-serif; font-size: 32px; font-weight: 800; line-height: 1; margin-bottom: 3px; }
  .stat.real .stat-num { color: var(--red); }
  .stat.new .stat-num { color: var(--orange); }
  .stat.minor .stat-num { color: var(--yellow); }
  .stat.fp .stat-num { color: var(--muted); }
  .stat.test .stat-num { color: var(--blue); }
  .stat-label { color: var(--muted); font-size: 10px; text-transform: uppercase; letter-spacing: 1px; }

  /* ─── SECTION ─── */
  .sec {
    font-family: 'Syne', sans-serif;
    font-size: 10px; font-weight: 700;
    text-transform: uppercase; letter-spacing: 3px;
    color: var(--muted);
    margin-bottom: 14px;
    display: flex; align-items: center; gap: 12px;
  }
  .sec::after { content: ''; flex: 1; height: 1px; background: var(--border); }

  /* ─── BUG CARDS ─── */
  .bugs { display: flex; flex-direction: column; gap: 10px; margin-bottom: 40px; }

  .bug {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 5px;
    overflow: hidden;
  }
  .bug:hover { border-color: #2a3240; }
  .bug.open { border-color: #2a3240; }

  .bug-header {
    display: grid;
    grid-template-columns: 44px 1fr auto;
    align-items: center;
    gap: 14px;
    padding: 14px 18px;
    cursor: pointer;
    user-select: none;
  }
  .bug.open .bug-header { border-bottom: 1px solid var(--border); }

  .bug-id { font-size: 10px; color: var(--muted); font-weight: 600; }

  .bug-info .bug-title { font-weight: 600; color: #dde4ed; font-size: 13px; }
  .bug-info .bug-file { font-size: 10.5px; color: var(--cyan); opacity: 0.6; margin-top: 2px; }

  .badges { display: flex; gap: 6px; align-items: center; flex-shrink: 0; }

  .badge {
    font-size: 9.5px; font-weight: 700; letter-spacing: 0.5px;
    padding: 2px 8px; border-radius: 3px; text-transform: uppercase;
  }
  .badge.critical { background: rgba(255,107,107,0.12); color: var(--red); border: 1px solid rgba(255,107,107,0.25); }
  .badge.high { background: rgba(255,159,67,0.12); color: var(--orange); border: 1px solid rgba(255,159,67,0.25); }
  .badge.medium { background: rgba(255,209,102,0.10); color: var(--yellow); border: 1px solid rgba(255,209,102,0.25); }
  .badge.low { background: rgba(116,185,255,0.10); color: var(--blue); border: 1px solid rgba(116,185,255,0.25); }
  .badge.fp { background: rgba(61,74,90,0.3); color: var(--muted); border: 1px solid var(--border); }
  .badge.new-tag { background: rgba(255,159,67,0.08); color: var(--orange); border: 1px solid rgba(255,159,67,0.2); font-size: 8.5px; }

  .bug-body { padding: 0 18px 18px 62px; }

  .desc {
    color: var(--text);
    margin: 14px 0 12px;
    font-size: 12px;
    line-height: 1.85;
  }

  .code {
    background: #060709;
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 14px;
    margin: 10px 0;
    overflow-x: auto;
    position: relative;
  }
  .code .tag {
    position: absolute; top: 7px; right: 10px;
    font-size: 9.5px; color: var(--muted);
  }
  pre { font-size: 11.5px; line-height: 1.7; color: #7a8fa6; }
  .bad { color: var(--red); background: rgba(255,107,107,0.06); display: block; padding: 0 14px; margin: 0 -14px; }
  .good { color: var(--accent); background: rgba(61,214,140,0.05); display: block; padding: 0 14px; margin: 0 -14px; }
  .cmt { color: #2a3a4a; font-style: italic; }
  .kw { color: var(--purple); }

  .fix-label {
    font-size: 10px; font-weight: 700; letter-spacing: 1px;
    text-transform: uppercase; color: var(--accent);
    margin: 14px 0 6px;
  }

  /* FP note */
  .fp-note {
    background: rgba(61,74,90,0.15);
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 12px 16px;
    margin-top: 14px;
    font-size: 11.5px;
    color: var(--muted);
  }
  .fp-note strong { color: var(--text); }

  /* ─── TEST TABLE ─── */
  .test-table { width: 100%; border-collapse: collapse; margin-bottom: 40px; }
  .test-table th {
    text-align: left; font-size: 10px; text-transform: uppercase;
    letter-spacing: 1px; color: var(--muted);
    padding: 9px 14px; border-bottom: 1px solid var(--border);
  }
  .test-table td {
    padding: 11px 14px; border-bottom: 1px solid var(--border);
    vertical-align: top; font-size: 11.5px;
  }
  .test-table tr:last-child td { border-bottom: none; }
  .test-table tr:hover td { background: var(--surface2); }

  .cmd { background: #060709; border: 1px solid var(--border); border-radius: 3px; padding: 2px 7px; color: var(--cyan); font-size: 11px; display: inline-block; margin: 1px 0; }
  .exp { color: var(--muted); font-size: 11px; }
  .exp b { color: var(--text); }

  .dot { width: 7px; height: 7px; border-radius: 50%; display: inline-block; margin-right: 5px; vertical-align: middle; }
  .dot.critical { background: var(--red); box-shadow: 0 0 5px var(--red); }
  .dot.high { background: var(--orange); box-shadow: 0 0 5px var(--orange); }
  .dot.medium { background: var(--yellow); }
  .dot.low { background: var(--blue); }
  .dot.fp { background: var(--muted); }

  .ref { font-size: 10px; color: var(--muted); display: block; margin-top: 2px; }

  footer {
    border-top: 1px solid var(--border);
    padding: 20px 56px;
    color: var(--muted);
    font-size: 10.5px;
    display: flex; justify-content: space-between;
  }
</style>
</head>
<body>

<header>
  <div>
    <div class="logo">mini<em>shell</em> · bug report <em style="font-size:16px;color:var(--muted)">v2</em></div>
    <div class="subtitle">Refactoredv3 · análise relida e corrigida</div>
  </div>
  <div class="meta">
    <strong>2026-02-21</strong>
    fshiniti / abroslav · 42 Porto
  </div>
</header>

<div class="container">

  <div class="correction-banner">
    <span class="icon">⚠</span>
    <div>
      <strong>Relatório anterior continha erros.</strong> Após releitura cuidadosa do código:
      <strong>B-01</strong> (pid não inicializado) era falso positivo — <code>wait_children</code> tem guard <code>if (last_pid &lt;= 0) return</code> e o return direto quando <code>pipe()</code> falha nunca chega ao <code>wait_children</code>.
      <strong>B-06</strong> (validate_syntax retorna 3) não quebra comportamento — <code>parser()</code> só testa <code>!= 0</code> e o exit_code exposto ao utilizador fica correto.
      Foram também identificados <strong>2 bugs novos reais</strong> não reportados anteriormente.
    </div>
  </div>

  <div class="summary">
    <div class="stat real">
      <div class="stat-num">5</div>
      <div class="stat-label">Bugs reais confirmados</div>
    </div>
    <div class="stat new">
      <div class="stat-num">2</div>
      <div class="stat-label">Bugs novos encontrados</div>
    </div>
    <div class="stat minor">
      <div class="stat-num">2</div>
      <div class="stat-label">Menores / código feio</div>
    </div>
    <div class="stat fp">
      <div class="stat-num">2</div>
      <div class="stat-label">Falsos positivos</div>
    </div>
    <div class="stat test">
      <div class="stat-num">12</div>
      <div class="stat-label">Testes críticos</div>
    </div>
  </div>

  <!-- ─── BUGS REAIS ─── -->
  <div class="sec">Bugs Reais Confirmados</div>
  <div class="bugs">

    <!-- B-02 -->
    <div class="bug open">
      <div class="bug-header" onclick="this.parentElement.classList.toggle('open')">
        <div class="bug-id">B-02</div>
        <div class="bug-info">
          <div class="bug-title">heredoc_fd não é fechado em free_cmds</div>
          <div class="bug-file">src/utils/free.c</div>
        </div>
        <div class="badges"><span class="badge critical">critical</span></div>
      </div>
      <div class="bug-body">
        <div class="desc">
          <code>free_cmds()</code> liberta args e redirs de cada comando mas nunca faz <code>close(tmp->heredoc_fd)</code>.
          Cada heredoc abre um fd temporário que fica vivo até o processo terminar.
          Com <code>valgrind --track-fds=yes</code> isto aparece como fd leak. Em sessões longas
          ou scripts com muitos heredocs, o processo pode atingir o limite do sistema (~1024 fds).
        </div>
        <div class="code">
          <span class="tag">free.c — free_cmds()</span>
          <pre><span class="kw">while</span> (cmds)
{
    tmp = cmds;
    cmds = cmds->next;
    <span class="kw">if</span> (tmp->args)    { ... free(tmp->args); }
    <span class="kw">if</span> (tmp->redirs)  free_redirs(tmp->redirs);
<span class="bad">    <span class="cmt">// heredoc_fd nunca fechado — leak de fd garantido</span></span>
    free(tmp);
}</pre>
        </div>
        <div class="fix-label">→ Fix</div>
        <div class="code">
          <pre>    if (tmp->redirs)  free_redirs(tmp->redirs);
<span class="good">    if (tmp->heredoc_fd >= 0)
        close(tmp->heredoc_fd);</span>
    free(tmp);</pre>
        </div>
      </div>
    </div>

    <!-- B-03 -->
    <div class="bug">
      <div class="bug-header" onclick="this.parentElement.classList.toggle('open')">
        <div class="bug-id">B-03</div>
        <div class="bug-info">
          <div class="bug-title">Ctrl+C durante heredoc trata-se como EOF</div>
          <div class="bug-file">src/heredoc/heredoc.c</div>
        </div>
        <div class="badges"><span class="badge critical">critical</span></div>
      </div>
      <div class="bug-body">
        <div class="desc">
          Quando o utilizador carrega Ctrl+C durante a leitura de um heredoc interativo,
          <code>readline()</code> devolve <code>NULL</code> — o mesmo que devolve no EOF (Ctrl+D).
          O código não distingue os dois casos: imprime o aviso de "delimited by end-of-file",
          cria um heredoc vazio, e continua a execução. O comportamento correto (bash) é abortar
          o heredoc, limpar o ficheiro temporário, e exibir nova prompt com exit_code 130.
          <code>g_last_signal</code> fica com <code>SIGINT</code> mas nunca é verificado aqui.
        </div>
        <div class="code">
          <span class="tag">heredoc.c — read_heredoc_lines()</span>
          <pre>    line = readline(<span style="color:#ffd166">"> "</span>);
<span class="bad">    if (!line)   <span class="cmt">// Ctrl+C e Ctrl+D tratados de forma idêntica</span>
    {
        ft_putstr_fd(<span style="color:#ffd166">"minishell: warning: here-doc..."</span>, 2);
        break;  <span class="cmt">// continua com heredoc vazio em vez de abortar</span>
    }</span></pre>
        </div>
        <div class="fix-label">→ Fix</div>
        <div class="code">
          <pre>    if (!line)
    {
<span class="good">        if (g_last_signal == SIGINT)
        {
            g_last_signal = 0;
            <span class="cmt">// fechar e apagar ficheiro temporário</span>
            close(ctx->fd);
            unlink(temp_file);
            return (-1);  <span class="cmt">// sinaliza abort ao chamador</span>
        }</span>
        ft_putstr_fd(<span style="color:#ffd166">"minishell: warning: ..."</span>, 2);
        break;
    }</pre>
        </div>
      </div>
    </div>

    <!-- B-05 -->
    <div class="bug">
      <div class="bug-header" onclick="this.parentElement.classList.toggle('open')">
        <div class="bug-id">B-05</div>
        <div class="bug-info">
          <div class="bug-title">check_open declarada no header mas nunca definida</div>
          <div class="bug-file">includes/minishell.h</div>
        </div>
        <div class="badges"><span class="badge high">high</span></div>
      </div>
      <div class="bug-body">
        <div class="desc">
          <code>minishell.h</code> declara <code>void check_open(char *file, int flags, int std_fd)</code>
          mas esta função não existe em nenhum ficheiro <code>.c</code>.
          Actualmente o código não a chama, por isso não há erro de linker.
          Se um avaliador ou colaborador tentar usar a declaração como referência e chamar a função,
          o linker vai falhar. Deve ser removida do header.
        </div>
        <div class="code">
          <span class="tag">minishell.h</span>
          <pre><span class="bad">void    check_open(char *file, int flags, int std_fd);
<span class="cmt">// declarada aqui — não existe em nenhum .c</span></span></pre>
        </div>
        <div class="fix-label">→ Fix</div>
        <div class="code">
          <pre><span class="good"><span class="cmt">// Remover esta linha do header</span></span></pre>
        </div>
      </div>
    </div>

    <!-- B-07 -->
    <div class="bug">
      <div class="bug-header" onclick="this.parentElement.classList.toggle('open')">
        <div class="bug-id">B-07</div>
        <div class="bug-info">
          <div class="bug-title">Campos de t_shell não inicializados em init_shell</div>
          <div class="bug-file">src/main.c</div>
        </div>
        <div class="badges"><span class="badge high">high</span></div>
      </div>
      <div class="bug-body">
        <div class="desc">
          <code>t_shell shell</code> é declarada na stack em <code>main()</code>.
          <code>init_shell()</code> inicializa <code>env_vars</code>, <code>exit_code</code>,
          <code>s_tokens</code> e <code>s_cmds</code> — mas deixa <code>export_vars</code>,
          <code>cmd_args</code> e <code>cmd_history</code> com lixo de stack.
          O ASAN pode reportar leituras de memória não-inicializada se qualquer código
          verificar estes campos. <code>free_all()</code> não os liberta — se algum dia
          forem usados sem inicialização, double-free ou uso de ponteiro inválido.
        </div>
        <div class="code">
          <span class="tag">main.c — init_shell()</span>
          <pre>    shell->env_vars  = copy_env(envp);
    shell->exit_code = 0;
    shell->s_tokens  = NULL;
    shell->s_cmds    = NULL;
<span class="bad">    <span class="cmt">// export_vars, cmd_args, cmd_history: lixo de stack</span></span></pre>
        </div>
        <div class="fix-label">→ Fix</div>
        <div class="code">
          <pre><span class="good">    shell->export_vars  = NULL;
    shell->cmd_args     = NULL;
    shell->cmd_history  = NULL;</span></pre>
        </div>
      </div>
    </div>

    <!-- B-08 -->
    <div class="bug">
      <div class="bug-header" onclick="this.parentElement.classList.toggle('open')">
        <div class="bug-id">B-08</div>
        <div class="bug-info">
          <div class="bug-title">ft_atoll_overflow aceita "42 " como número válido</div>
          <div class="bug-file">src/utils/utils2.c</div>
        </div>
        <div class="badges"><span class="badge medium">medium</span></div>
      </div>
      <div class="bug-body">
        <div class="desc">
          A função consome espaços a seguir ao número antes de verificar se chegou ao fim da string.
          Isso faz com que <code>"42 "</code> seja aceite como 42 sem erro.
          Bash rejeita <code>exit "42 "</code> com "numeric argument required" (exit code 2).
          O minishell aceita e faz exit(42) — comportamento incorreto.
        </div>
        <div class="code">
          <span class="tag">utils2.c — ft_atoll_overflow()</span>
          <pre>    <span class="kw">while</span> (str[i] >= '0' && str[i] <= '9') { nmbr = ...; i++; }
<span class="bad">    while (ft_isspace(str[i])) i++;   <span class="cmt">// consome "  " → str[i] == '\0'</span>
    *res = nmbr * sign;
    return (str[i] != '\0');          <span class="cmt">// "42 " retorna 0 (sem erro) — errado</span></span></pre>
        </div>
        <div class="fix-label">→ Fix</div>
        <div class="code">
          <pre>    <span class="kw">while</span> (str[i] >= '0' && str[i] <= '9') { nmbr = ...; i++; }
<span class="good">    <span class="cmt">// Não consumir trailing spaces — bash rejeita "42 "</span></span>
    *res = nmbr * sign;
    return (str[i] != '\0');</pre>
        </div>
      </div>
    </div>

  </div>

  <!-- ─── BUGS NOVOS ─── -->
  <div class="sec">Bugs Novos (não reportados anteriormente)</div>
  <div class="bugs">

    <!-- N-01 -->
    <div class="bug">
      <div class="bug-header" onclick="this.parentElement.classList.toggle('open')">
        <div class="bug-id">N-01</div>
        <div class="bug-info">
          <div class="bug-title">Múltiplos heredocs no mesmo comando — fds anteriores perdidos</div>
          <div class="bug-file">src/heredoc/heredoc.c — process_heredocs()</div>
        </div>
        <div class="badges"><span class="badge new-tag">novo</span><span class="badge critical">critical</span></div>
      </div>
      <div class="bug-body">
        <div class="desc">
          <code>t_cmd</code> tem apenas um campo <code>heredoc_fd</code> (um único int).
          <code>process_heredocs()</code> itera todos os <code>REDIR_HEREDOC</code> de um comando
          e em cada um faz <code>cmd->heredoc_fd = handle_heredoc(...)</code>.
          Se um comando tiver dois heredocs (<code>cat &lt;&lt; A &lt;&lt; B</code>), o fd do
          primeiro heredoc é sobrescrito pelo segundo e fica aberto sem referência — leak de fd garantido.
          O bash usa apenas o último heredoc como stdin (comportamento idêntico ao da última redireção),
          por isso o resultado final é correto — mas o fd do primeiro nunca é fechado.
        </div>
        <div class="code">
          <span class="tag">heredoc.c — process_heredocs()</span>
          <pre>    while (redir)
    {
        <span class="kw">if</span> (redir->type == REDIR_HEREDOC)
<span class="bad">            cmd->heredoc_fd = handle_heredoc(...);
            <span class="cmt">// se já havia um fd aberto, é sobrescrito — leak</span></span>
        redir = redir->next;
    }</pre>
        </div>
        <div class="fix-label">→ Fix</div>
        <div class="code">
          <pre>        <span class="kw">if</span> (redir->type == REDIR_HEREDOC)
        {
<span class="good">            if (cmd->heredoc_fd >= 0)
                close(cmd->heredoc_fd);  <span class="cmt">// fechar o anterior</span></span>
            cmd->heredoc_fd = handle_heredoc(...);
        }</pre>
        </div>
      </div>
    </div>

    <!-- N-02 -->
    <div class="bug">
      <div class="bug-header" onclick="this.parentElement.classList.toggle('open')">
        <div class="bug-id">N-02</div>
        <div class="bug-info">
          <div class="bug-title">rl_clear_history chamado em processo filho</div>
          <div class="bug-file">src/utils/free.c — cleanup_exit_child()</div>
        </div>
        <div class="badges"><span class="badge new-tag">novo</span><span class="badge medium">medium</span></div>
      </div>
      <div class="bug-body">
        <div class="desc">
          <code>cleanup_exit_child()</code> chama <code>free_all()</code> que por sua vez chama
          <code>rl_clear_history()</code>. Esta função é chamada em processos filho (forked),
          onde a readline nunca foi inicializada. Embora na prática a maioria das implementações
          da libreadline tolere isto, é tecnicamente comportamento indefinido — a lista de histórico
          do processo filho é uma cópia da do pai (copy-on-write), e manipulá-la pode causar
          problemas com algumas versões ou configurações do ASAN.
        </div>
        <div class="code">
          <span class="tag">free.c — free_all()</span>
          <pre>void free_all(t_shell *shell)
{
    ...
<span class="bad">    rl_clear_history();  <span class="cmt">// chamado em filhos — readline não foi usada aqui</span></span>
}</pre>
        </div>
        <div class="fix-label">→ Fix</div>
        <div class="code">
          <pre><span class="good"><span class="cmt">// Opção 1: separar free_all_child() sem rl_clear_history</span>
<span class="cmt">// Opção 2: só chamar rl_clear_history no processo pai</span></span>
void cleanup_exit_child(t_shell *shell, int exit_code)
{
<span class="good">    free_env(shell->env_vars);
    free_tokens(shell->s_tokens);
    free_cmds(shell->s_cmds);
    <span class="cmt">// sem rl_clear_history aqui</span></span>
    exit(exit_code);
}</pre>
        </div>
      </div>
    </div>

  </div>

  <!-- ─── MENORES / CÓDIGO FEIO ─── -->
  <div class="sec">Menores — Não quebram comportamento</div>
  <div class="bugs">

    <!-- M-01 -->
    <div class="bug">
      <div class="bug-header" onclick="this.parentElement.classList.toggle('open')">
        <div class="bug-id">M-01</div>
        <div class="bug-info">
          <div class="bug-title">Nome do ficheiro temporário de heredoc com espaço</div>
          <div class="bug-file">src/heredoc/heredoc_utils.c</div>
        </div>
        <div class="badges"><span class="badge low">minor</span></div>
      </div>
      <div class="bug-body">
        <div class="desc">
          <code>heredoc_gen_temp_filename()</code> gera <code>". heredoc_tmp_0"</code> — com um ponto
          e um espaço, criado no directório actual de trabalho. <code>open()</code> aceita espaços
          em nomes de ficheiros, por isso não quebra. Mas é má prática: polui o CWD, pode aparecer
          em listagens, e se o shell for invocado num directório sem permissão de escrita vai falhar.
          Melhor usar <code>/tmp/</code>.
        </div>
        <div class="code">
          <span class="tag">heredoc_utils.c</span>
          <pre><span class="bad">filename = ft_strjoin(". heredoc_tmp_", num);
<span class="cmt">// cria ". heredoc_tmp_0" no CWD — espaço + directório errado</span></span></pre>
        </div>
        <div class="fix-label">→ Fix</div>
        <div class="code">
          <pre><span class="good">filename = ft_strjoin("/tmp/.minishell_hd_", num);</span></pre>
        </div>
      </div>
    </div>

    <!-- M-02 -->
    <div class="bug">
      <div class="bug-header" onclick="this.parentElement.classList.toggle('open')">
        <div class="bug-id">M-02</div>
        <div class="bug-info">
          <div class="bug-title">validate_syntax — expressão + !0 desnecessária</div>
          <div class="bug-file">src/parser/parser.c</div>
        </div>
        <div class="badges"><span class="badge low">minor</span></div>
      </div>
      <div class="bug-body">
        <div class="desc">
          <code>return (check_pipe_syntax(current) + !0)</code> é equivalente a
          <code>return (check_pipe_syntax(current) + 1)</code> que pode devolver 3 em vez de 2.
          <code>parser()</code> só testa <code>!= 0</code> e o exit_code exposto é sempre 2
          (definido antes do return), por isso o comportamento visível está correto.
          Mas é código confuso e provavelmente um typo de <code>!= 0</code>.
        </div>
        <div class="code">
          <span class="tag">parser.c</span>
          <pre>  if (current->type == TK_PIPE)
<span class="bad">      return (check_pipe_syntax(current) + !0);
      <span class="cmt">// !0 == 1 → pode devolver 3. Typo de != 0 ?</span></span></pre>
        </div>
        <div class="fix-label">→ Fix</div>
        <div class="code">
          <pre><span class="good">      return (check_pipe_syntax(current));</span></pre>
        </div>
      </div>
    </div>

  </div>

  <!-- ─── FALSOS POSITIVOS ─── -->
  <div class="sec">Falsos Positivos do Relatório Anterior</div>
  <div class="bugs">

    <div class="bug">
      <div class="bug-header" onclick="this.parentElement.classList.toggle('open')">
        <div class="bug-id">B-01</div>
        <div class="bug-info">
          <div class="bug-title">pid não inicializado em execute_pipe</div>
          <div class="bug-file">src/exec/execute.c</div>
        </div>
        <div class="badges"><span class="badge fp">falso positivo</span></div>
      </div>
      <div class="bug-body">
        <div class="fp-note">
          <strong>Não é bug.</strong> O cenário reportado não pode ocorrer:
          <br>• Se <code>pipe()</code> falha → <code>return</code> direto, <code>wait_children</code> nunca é chamado.
          <br>• Se <code>fork()</code> falha → <code>pid = -1</code>, e <code>wait_children</code> tem guard explícita: <code>if (last_pid &lt;= 0) return</code>.
          <br>• O loop só é atingido se <code>cmd != NULL</code> (garantido por <code>executor()</code> que verifica <code>if (!cmd) return</code>).
          <br>O código é defensivo e correto neste aspecto.
        </div>
      </div>
    </div>

    <div class="bug">
      <div class="bug-header" onclick="this.parentElement.classList.toggle('open')">
        <div class="bug-id">B-06</div>
        <div class="bug-info">
          <div class="bug-title">validate_syntax retorna 3 em vez de 2</div>
          <div class="bug-file">src/parser/parser.c</div>
        </div>
        <div class="badges"><span class="badge fp">falso positivo</span></div>
      </div>
      <div class="bug-body">
        <div class="fp-note">
          <strong>Não quebra comportamento.</strong> <code>parser()</code> só verifica <code>if (validate_syntax(tokens) != 0)</code>
          — qualquer valor não-zero tem o mesmo efeito. Antes de <code>return NULL</code>,
          o parser faz <code>shell->exit_code = 2</code> explicitamente, portanto o exit_code
          exposto ao utilizador está sempre correto (2 para erro de sintaxe).
          É código confuso / typo (ver M-02), mas não é um bug funcional.
        </div>
      </div>
    </div>

  </div>

  <!-- ─── TESTES ─── -->
  <div class="sec" style="margin-top:8px">Testes que Podem Quebrar</div>

  <table class="test-table">
    <thead>
      <tr>
        <th>#</th>
        <th>Comando</th>
        <th>Esperado (bash)</th>
        <th>Bug relacionado / Risco</th>
      </tr>
    </thead>
    <tbody>

      <tr>
        <td style="color:var(--muted)">T-01</td>
        <td><span class="cmd">cat &lt;&lt; A &lt;&lt; B</span><br><em style="font-size:10px;color:var(--muted)">dois heredocs no mesmo cmd</em></td>
        <td><span class="exp">Usa B como stdin, <b>sem leak de fds</b></span></td>
        <td><span class="dot critical"></span>N-01: fd do primeiro heredoc é perdido</td>
      </tr>

      <tr>
        <td style="color:var(--muted)">T-02</td>
        <td><span class="cmd">cat &lt;&lt; EOF</span> → Ctrl+C durante input</td>
        <td><span class="exp">Nova prompt, <b>exit_code = 130</b></span></td>
        <td><span class="dot critical"></span>B-03: heredoc continua com ficheiro vazio</td>
      </tr>

      <tr>
        <td style="color:var(--muted)">T-03</td>
        <td>
          <span class="cmd">valgrind --track-fds=yes ./minishell</span><br>
          executar 20x <span class="cmd">cat &lt;&lt; EOF</span>, depois <span class="cmd">exit</span>
        </td>
        <td><span class="exp"><b>0 fds abertos</b> no fim</span></td>
        <td><span class="dot critical"></span>B-02 + N-01: fds de heredoc nunca fechados</td>
      </tr>

      <tr>
        <td style="color:var(--muted)">T-04</td>
        <td><span class="cmd">exit "42 "</span></td>
        <td><span class="exp">numeric argument required, exit <b>2</b></span></td>
        <td><span class="dot high"></span>B-08: aceita "42 " como válido → exit(42)</td>
      </tr>

      <tr>
        <td style="color:var(--muted)">T-05</td>
        <td><span class="cmd">exit "  "</span> e <span class="cmd">exit "abc"</span></td>
        <td><span class="exp">Ambos: numeric argument required, exit <b>2</b></span></td>
        <td><span class="dot high"></span>B-08: "  " pode ser aceite como 0</td>
      </tr>

      <tr>
        <td style="color:var(--muted)">T-06</td>
        <td><span class="cmd">echo "unclosed</span> <em style="font-size:10px;color:var(--muted)">(sem fechar aspas)</em></td>
        <td><span class="exp">Erro de sintaxe, exit <b>2</b>, nova prompt sem crash</span></td>
        <td><span class="dot high"></span>validate_line deve detectar — confirmar exit_code</td>
      </tr>

      <tr>
        <td style="color:var(--muted)">T-07</td>
        <td><span class="cmd">ls &gt; /tmp/f1 &gt; /tmp/f2 &gt; /tmp/f3</span></td>
        <td><span class="exp">Output em f3, f1 e f2 criados e vazios</span></td>
        <td><span class="dot high"></span>Testar múltiplos redirs do mesmo tipo</td>
      </tr>

      <tr>
        <td style="color:var(--muted)">T-08</td>
        <td>
          <span class="cmd">cat &lt;&lt; EOF</span> com linha de 1025 caracteres
        </td>
        <td><span class="exp">Linha completa passada ao cat</span></td>
        <td><span class="dot high"></span>B-09: buffer de 1024 trunca a linha em modo não-tty</td>
      </tr>

      <tr>
        <td style="color:var(--muted)">T-09</td>
        <td><span class="cmd">./minishell &lt; script.sh</span><br><em style="font-size:10px;color:var(--muted)">com heredoc no script</em></td>
        <td><span class="exp">Heredoc lido sem prompt, sem truncagem</span></td>
        <td><span class="dot medium"></span>B-09: heredoc_read_line tem buffer de 1024</td>
      </tr>

      <tr>
        <td style="color:var(--muted)">T-10</td>
        <td>
          <span class="cmd">cat &lt;&lt; 'EOF'</span> com <span class="cmd">$HOME</span> no corpo
        </td>
        <td><span class="exp">Imprime <b>$HOME</b> literalmente, sem expansão</span></td>
        <td><span class="dot medium"></span>Testar que heredoc_has_quotes desactiva expansão</td>
      </tr>

      <tr>
        <td style="color:var(--muted)">T-11</td>
        <td><span class="cmd">| echo hi</span></td>
        <td><span class="exp">Syntax error, exit <b>2</b></span></td>
        <td><span class="dot medium"></span>M-02: validate_syntax retorna 3, exit_code correto?</td>
      </tr>

      <tr>
        <td style="color:var(--muted)">T-12</td>
        <td>
          Loop com 200 iterações de <span class="cmd">cat &lt;&lt; A &lt;&lt; B</span>
        </td>
        <td><span class="exp">Sem "too many open files" error</span></td>
        <td><span class="dot critical"></span>N-01 + B-02 combinados: esgotar fds do sistema</td>
      </tr>

    </tbody>
  </table>

</div>

<footer>
  <div>minishell · Refactoredv3 · 42 Porto · relatório v2 (corrigido)</div>
  <div>5 bugs reais · 2 novos · 2 falsos positivos corrigidos · 12 testes</div>
</footer>

<script>
  document.querySelectorAll('.bug:not(.open)').forEach(b => {
    b.querySelector('.bug-body') && (b.querySelector('.bug-body').style.display = 'none');
  });
  document.querySelectorAll('.bug-header').forEach(h => {
    h.addEventListener('click', () => {
      const bug = h.parentElement;
      const body = bug.querySelector('.bug-body');
      if (!body) return;
      const isOpen = bug.classList.contains('open');
      bug.classList.toggle('open', !isOpen);
      body.style.display = isOpen ? 'none' : 'block';
    });
  });
  document.querySelectorAll('.bug.open .bug-body').forEach(b => b.style.display = 'block');
</script>
</body>
</html>
